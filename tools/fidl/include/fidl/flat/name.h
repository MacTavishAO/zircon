// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef ZIRCON_TOOLS_FIDL_INCLUDE_FIDL_FLAT_NAME_H_
#define ZIRCON_TOOLS_FIDL_INCLUDE_FIDL_FLAT_NAME_H_

namespace fidl {
namespace flat {

class Library;

// Name represents a named entry in a particular scope.

// Names have different flavors based on their origins, which can be determined by the discriminant
// `Name::Kind`. See the documentation for `Name::Kind` for details.
class Name final {
 public:
  // Discriminant for the kind of name, which is dictated by the origins of the name.
  enum class Kind {
    // Represents a name that is directly represented in source.
    kSourced,

    // Represents a name that is created or derived from a context encompassed
    // by a source span.
    kDerived,

    // Represents a name that is intrinsic to the language or generated by the
    // compiler, with no attachments to source.
    kIntrinsic,
  };

  // Helper type to use when looking up and comparing names. This may be useful for associative
  // containers.
  //
  // Note that this type contains `std::string_view`s, so it must not outlive the strings its
  // members reference.
  class Key final {
   public:
    // Intentionally allow for implicit conversions from `Name`, as `Name` should be freely
    // convertible to its `Key`.
    //
    // NOLINTNEXTLINE
    Key(const Name& name)
        : compare_context_(name.library(), name.decl_name(),
                           name.member_name().has_value()
                               ? std::make_optional(std::string_view(name.member_name().value()))
                               : std::nullopt) {}

    explicit Key(const Library* library, std::string_view decl_name)
        : compare_context_(library, decl_name, std::nullopt) {}

    explicit Key(const Library* library, std::string_view decl_name, std::string_view member_name)
        : compare_context_(library, decl_name, member_name) {}

    friend bool operator==(const Key& lhs, const Key& rhs) {
      return lhs.compare_context_ == rhs.compare_context_;
    }

    friend bool operator!=(const Key& lhs, const Key& rhs) {
      return lhs.compare_context_ != rhs.compare_context_;
    }

    friend bool operator<(const Key& lhs, const Key& rhs) {
      return lhs.compare_context_ < rhs.compare_context_;
    }

   private:
    using CompareContext =
        std::tuple<const Library*, std::string_view, std::optional<std::string_view>>;

    CompareContext compare_context_;
  };

  static Name CreateSourced(const Library* library, SourceSpan span) {
    return Name(library, SourcedNameContext(span), std::nullopt);
  }

  static Name CreateSourced(const Library* library, SourceSpan span, std::string member_name) {
    return Name(library, SourcedNameContext(span), member_name);
  }

  static Name CreateDerived(const Library* library, SourceSpan span, std::string name) {
    return Name(library, DerivedNameContext(std::move(name), span), std::nullopt);
  }

  static Name CreateIntrinsic(std::string name) {
    return Name(nullptr, IntrinsicNameContext(std::move(name)), std::nullopt);
  }

  Name(const Name& other) noexcept
      : kind_(other.kind_),
        library_(other.library_),
        name_context_{.uninitialized = std::monostate()},  // Initialized in the body
        member_name_(other.member_name_) {
    switch (kind_) {
      case Kind::kSourced:
        new (&name_context_.sourced) SourcedNameContext(other.name_context_.sourced);
        break;
      case Kind::kDerived:
        new (&name_context_.derived) DerivedNameContext(other.name_context_.derived);
        break;
      case Kind::kIntrinsic:
        new (&name_context_.intrinsic) IntrinsicNameContext(other.name_context_.intrinsic);
        break;
    }
  }

  Name(Name&& other) noexcept
      : kind_(other.kind_),
        library_(std::move(other.library_)),
        name_context_{.uninitialized = std::monostate()},  // Initialized in the body
        member_name_(std::move(other.member_name_)) {
    other.library_ = nullptr;

    switch (kind_) {
      case Kind::kSourced:
        new (&name_context_.sourced) SourcedNameContext(std::move(other.name_context_.sourced));
        break;
      case Kind::kDerived:
        new (&name_context_.derived) DerivedNameContext(std::move(other.name_context_.derived));
        break;
      case Kind::kIntrinsic:
        new (&name_context_.intrinsic)
            IntrinsicNameContext(std::move(other.name_context_.intrinsic));
        break;
    }
  }

  Name& operator=(const Name& other) noexcept {
    if (&other == this) {
      return *this;
    }

    kind_ = other.kind_;
    library_ = other.library_;

    switch (other.kind_) {
      case Kind::kSourced:
        name_context_.sourced = other.name_context_.sourced;
        break;
      case Kind::kDerived:
        name_context_.derived = other.name_context_.derived;
        break;
      case Kind::kIntrinsic:
        name_context_.intrinsic = other.name_context_.intrinsic;
        break;
    }

    return *this;
  }

  Name& operator=(Name&& other) noexcept {
    if (&other == this) {
      return *this;
    }

    kind_ = other.kind_;
    library_ = other.library_;
    other.library_ = nullptr;

    switch (other.kind_) {
      case Kind::kSourced:
        name_context_.sourced = std::move(other.name_context_.sourced);
        break;
      case Kind::kDerived:
        name_context_.derived = std::move(other.name_context_.derived);
        break;
      case Kind::kIntrinsic:
        name_context_.intrinsic = std::move(other.name_context_.intrinsic);
        break;
    }

    return *this;
  }

  ~Name() {
    switch (kind_) {
      case Kind::kSourced:
        name_context_.sourced.~SourcedNameContext();
        break;
      case Kind::kDerived:
        name_context_.derived.~DerivedNameContext();
        break;
      case Kind::kIntrinsic:
        name_context_.intrinsic.~IntrinsicNameContext();
        break;
    }
  }

  Kind kind() const { return kind_; }

  const Library* library() const { return library_; }

  std::optional<SourceSpan> span() const {
    switch (kind_) {
      case Kind::kSourced:
        return name_context_.sourced.span;
      case Kind::kDerived:
        return name_context_.derived.span;
      case Kind::kIntrinsic:
        return std::nullopt;
    }
  }

  std::string_view decl_name() const {
    switch (kind_) {
      case Kind::kSourced:
        return name_context_.sourced.span.data();
      case Kind::kDerived:
        return std::string_view(name_context_.derived.name);
      case Kind::kIntrinsic:
        return std::string_view(name_context_.intrinsic.name);
    }
  }

  std::string full_name() const {
    auto name = std::string(decl_name());
    if (member_name_.has_value()) {
      constexpr std::string_view kSeparator = ".";
      name.reserve(name.size() + kSeparator.size() + member_name_.value().size());

      name.append(kSeparator);
      name.append(member_name_.value());
    }
    return name;
  }

  const std::optional<std::string>& member_name() const { return member_name_; }

  Key memberless_key() const { return Key(library_, decl_name()); }

  Key key() const { return Key(*this); }

  friend bool operator==(const Name& lhs, const Name& rhs) { return lhs.key() == rhs.key(); }

  friend bool operator!=(const Name& lhs, const Name& rhs) { return lhs.key() != rhs.key(); }

  friend bool operator<(const Name& lhs, const Name& rhs) { return lhs.key() < rhs.key(); }

 private:
  struct SourcedNameContext {
    explicit SourcedNameContext(SourceSpan span) : span(span) {}

    // The span of the name.
    SourceSpan span;
  };

  struct DerivedNameContext {
    explicit DerivedNameContext(std::string name, SourceSpan span)
        : name(std::move(name)), span(span) {}

    // The derived name.
    std::string name;

    // The span from which the name was derived.
    SourceSpan span;
  };

  struct IntrinsicNameContext {
    explicit IntrinsicNameContext(std::string name) : name(std::move(name)) {}

    // The intrinsic name.
    std::string name;
  };

  // This union is tagged externally by `Kind`.
  //
  // The owning type must properly destruct the correct variant.
  union NameContext {
    // This uninitialized state should only be used during construction.
    std::monostate uninitialized;
    SourcedNameContext sourced;
    DerivedNameContext derived;
    IntrinsicNameContext intrinsic;

    ~NameContext() {}
  };

  Name(const Library* library, SourcedNameContext name_context,
       std::optional<std::string> member_name)
      : kind_(Kind::kSourced),
        library_(library),
        name_context_{.sourced = std::move(name_context)},
        member_name_(std::move(member_name)) {}

  Name(const Library* library, DerivedNameContext name_context,
       std::optional<std::string> member_name)
      : kind_(Kind::kDerived),
        library_(library),
        name_context_{.derived = std::move(name_context)},
        member_name_(std::move(member_name)) {}

  Name(const Library* library, IntrinsicNameContext name_context,
       std::optional<std::string> member_name)
      : kind_(Kind::kIntrinsic),
        library_(library),
        name_context_{.intrinsic = std::move(name_context)},
        member_name_(std::move(member_name)) {}

  Kind kind_;
  const Library* library_;
  NameContext name_context_;
  std::optional<std::string> member_name_;
};

}  // namespace flat
}  // namespace fidl

#endif  // ZIRCON_TOOLS_FIDL_INCLUDE_FIDL_FLAT_NAME_H_
