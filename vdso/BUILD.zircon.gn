# Copyright 2020 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("$zx/public/gn/toolchain/c_utils.gni")
import("$zx_build/public/gn/fidl.gni")
import("vdso.gni")

group("vdso") {
  public_deps = [ ":zx" ]
}

group("json") {
  public_deps = [ ":zx.json" ]
}

# The system calls are defined as if they were a FIDL library, because
# kazoo consumes the FIDL JSON IR (generated below).  This cannot be used
# like a normal fidl_library, however.  Only the "json" subtarget is
# available.
#
# TODO(fxbug.dev/7802): Merge with vdso/zx:zx.
fidl_library("zx") {
  visibility = [ ":*" ]
  targets = [ "fidl_json_rspfile" ]
  sources = all_syscall_fidl_files
}

# The generated stuff is identical regardless of how it gets compiled.
# Dependents must use "$zx/vdso:public($default_toolchain)" or
# "$zx/vdso:private($default_toolchain)".
assert(current_toolchain == default_toolchain)

# This provides the public headers that go with the vDSO API, which are
# seen as <zircon/...>.
group("public") {
  visibility = [ "$zx/system/ulib/zircon/*" ]
  public_configs = [ ":public.config" ]
  public_deps = [ ":generate" ]
}

public_gen_dir = "$root_gen_dir/include/zircon/syscalls"
config("public.config") {
  visibility = [ ":public" ]
  include_dirs = [ "$root_gen_dir/include" ]
}

# This provides the private headers used by the kernel and vDSO
# implementation, which are seen as <lib/syscalls/...>.
group("private") {
  visibility = [
    "$zx/kernel/lib/syscalls/*",
    "$zx/system/ulib/syscalls-headers/*",
    "$zx/system/ulib/zircon/*",
  ]
  public_configs = [ ":private.config" ]
  public_deps = [ ":generate" ]
}

private_gen_dir = "$target_gen_dir/include/lib/syscalls"
config("private.config") {
  visibility = [ ":private" ]
  include_dirs = [ "$target_gen_dir/include" ]
}

# Generate a file that contains the path to the generated JSON IR file.
fidl_library_json_rspfile("json.rspfile") {
  visibility = [ ":*" ]
  output = "$target_gen_dir/json.rspfile"
  deps = [ ":json" ]
}

# The kazoo compiler translates FIDL's IR into syscall-oriented outputs.
# These are logically distinct things that are used by different modules in
# the kernel or in public library code.  But they all depend on the same
# inputs, the front-end work is the same for each one, and the back-end
# work is not very costly.  So doing a single kazoo run to generate them
# all together is faster than parallelizing the independent generation
# steps that duplicate redundant process overhead and front-end work.

# NOTE: Rust bindings are now generated by the GN build, see
# src/lib/zircon/BUILD.gn.

public_generated = [
  {
    args = [ "--json" ]
    outputs = [ "$public_gen_dir/definitions.json" ]
  },
  {
    args = [ "--public-header" ]
    outputs = [ "$public_gen_dir/internal/cdecls.inc" ]
  },
]

if (!exclude_testonly_syscalls) {
  public_generated += [
    {
      args = [ "--testonly-public-header" ]
      outputs = [ "$public_gen_dir/internal/testonly-cdecls.inc" ]
    },
  ]
}

private_generated = [
  {
    args = [ "--category" ]
    outputs = [ "$private_gen_dir/category.inc" ]
  },
  {
    args = [ "--syscall-numbers" ]
    outputs = [ "$private_gen_dir/zx-syscall-numbers.h" ]
  },
  {
    args = [ "--kernel-header" ]
    outputs = [ "$private_gen_dir/kernel.inc" ]
  },
  {
    args = [ "--kernel-wrappers" ]
    outputs = [ "$private_gen_dir/kernel-wrappers.inc" ]
  },
  {
    args = [ "--private-header" ]
    outputs = [ "$private_gen_dir/syscalls.inc" ]
  },
]

host_tool_action("generate") {
  visibility = [
    ":private",
    ":public",
  ]

  tool = "$zx/tools/kazoo"

  args = []
  if (exclude_testonly_syscalls) {
    args += [ "--exclude=testonly" ]
  }

  outputs = []
  foreach(gen, public_generated + private_generated) {
    args += gen.args + rebase_path(gen.outputs, root_build_dir)
    outputs += gen.outputs
  }

  deps = [ ":json.rspfile" ]
  sources = get_target_outputs(deps[0])
  assert(sources == [ sources[0] ])  # There can be only one.
  args += [ "@" + rebase_path(sources[0], root_build_dir) ]

  metadata = {
    generated_sources = rebase_path(outputs, root_build_dir)
  }
}
